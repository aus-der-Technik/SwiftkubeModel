//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.19.8
/// certificates.v1.CertificateSigningRequestSpec
///

import Foundation

public extension certificates.v1 {

	///
	/// CertificateSigningRequestSpec contains the certificate request.
	///
	struct CertificateSigningRequestSpec: KubernetesResource {
		///
		/// extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
		///
		public var extra: [String: [String]]?
		///
		/// groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
		///
		public var groups: [String]?
		///
		/// request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.
		///
		public var request: String
		///
		/// signerName indicates the requested signer, and is a qualified name.
		///
		/// List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
		///
		/// Well-known Kubernetes signers are:
		///  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
		///   Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
		///  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
		///   Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
		///  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
		///   Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
		///
		/// More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
		///
		/// Custom signerNames can also be specified. The signer defines:
		///  1. Trust distribution: how trust (CA bundles) are distributed.
		///  2. Permitted subjects: and behavior when a disallowed subject is requested.
		///  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
		///  4. Required, permitted, or forbidden key usages / extended key usages.
		///  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
		///  6. Whether or not requests for CA certificates are allowed.
		///
		public var signerName: String
		///
		/// uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
		///
		public var uid: String?
		///
		/// usages specifies a set of key usages requested in the issued certificate.
		///
		/// Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
		///
		/// Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
		///
		/// Valid values are:
		///  "signing", "digital signature", "content commitment",
		///  "key encipherment", "key agreement", "data encipherment",
		///  "cert sign", "crl sign", "encipher only", "decipher only", "any",
		///  "server auth", "client auth",
		///  "code signing", "email protection", "s/mime",
		///  "ipsec end system", "ipsec tunnel", "ipsec user",
		///  "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
		///
		public var usages: [String]?
		///
		/// username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.
		///
		public var username: String?
		///
		/// Default memberwise initializer
		///
		public init(
			extra: [String: [String]]? = nil,
			groups: [String]? = nil,
			request: String,
			signerName: String,
			uid: String? = nil,
			usages: [String]? = nil,
			username: String? = nil
		) {
			self.extra = extra
			self.groups = groups
			self.request = request
			self.signerName = signerName
			self.uid = uid
			self.usages = usages
			self.username = username
		}
	}
}

///
/// Codable conformance
///
public extension certificates.v1.CertificateSigningRequestSpec {

	private enum CodingKeys: String, CodingKey {

		case extra = "extra"
		case groups = "groups"
		case request = "request"
		case signerName = "signerName"
		case uid = "uid"
		case usages = "usages"
		case username = "username"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.extra = try container.decodeIfPresent([String: [String]].self, forKey: .extra)
		self.groups = try container.decodeIfPresent([String].self, forKey: .groups)
		self.request = try container.decode(String.self, forKey: .request)
		self.signerName = try container.decode(String.self, forKey: .signerName)
		self.uid = try container.decodeIfPresent(String.self, forKey: .uid)
		self.usages = try container.decodeIfPresent([String].self, forKey: .usages)
		self.username = try container.decodeIfPresent(String.self, forKey: .username)
	}

	func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: CodingKeys.self)

		try container.encode(extra, forKey: .extra)
		try container.encode(groups, forKey: .groups)
		try container.encode(request, forKey: .request)
		try container.encode(signerName, forKey: .signerName)
		try container.encode(uid, forKey: .uid)
		try container.encode(usages, forKey: .usages)
		try container.encode(username, forKey: .username)
	}
}
